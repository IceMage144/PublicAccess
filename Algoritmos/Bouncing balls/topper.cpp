#include <SFML/Graphics.hpp>
#include <vector>
#include <iostream>
#include <cmath>

using namespace std;

// Physical constants
#define TAU 6.283185
#define PI 3.141592
#define g 9.80665
#define airden 1.225
#define circcons 0.47
#define G 0.00000000006674
#define MMass 10000000000000.0

// Display constants
#define video_max_x 1000
#define video_max_y 600

// Colors
#define MWhite sf::Color(255, 255, 255)
#define MBlack sf::Color(0, 0, 0)
#define Blue sf::Color(0, 0, 255)
#define Red sf::Color(255, 0, 0)

inline float sq(float num) {
    return num*num;
}

struct Vector2d {
    double x, y;
    Vector2d(): x(0), y(0) {};
    Vector2d(double x, double y): x(x), y(y) {};
};

Vector2d vsum(Vector2d v1, Vector2d v2) {
    Vector2d res(v1.x+v2.x, v1.y+v2.y);
    return res;
}

Vector2d vsub(Vector2d v1, Vector2d v2) {
    Vector2d res(v1.x-v2.x, v1.y-v2.y);
    return res;
}

double dprod(Vector2d v1, Vector2d v2) {
    return v1.x*v2.x + v1.y*v2.y;
}

Vector2d rprod(double num, Vector2d v) {
    Vector2d res(num*v.x, num*v.y);
    return res;
}

Vector2d rdiv(double num, Vector2d v) {
    Vector2d res(v.x/num, v.y/num);
    return res;
}

double snorm(Vector2d v) {
    return sq(v.x)+sq(v.y);
}

double direction(Vector2d v) {
    if (v.x != 0 && v.y != 0)
        return atan2(v.y, v.x);
    return 0;
}

class physical_object {
public:
    double x, y, mass, airrescons, volume;
    bool grav, airres, buoy;
    Vector2d velocity;
    Vector2d get_pos();
    Vector2d get_velocity();
    double get_mass() {
        return mass;
    };
    virtual char type() = 0;
    void set_pos(double ax, double ay) {
        x = ax;
        y = ay;
    }
    void gravity(bool boo) {
        grav = boo;
    };
    void air_resistance(bool boo) {
        airres = boo;
    };
    void bouyancy(bool boo) {
        buoy = boo;
    };
    void apply_e_gravity();
    void apply_g_gravity(physical_object& other);
    virtual void apply_air_resistance() = 0;
    void apply_buoyancy() {
        if (buoy)
            velocity.y -= airden*g*volume/10000000;
    };
    void apply_velocity();
    void add_velocity(Vector2d vec) {
        velocity = vsum(velocity, vec);
    };
    void change_velocity(Vector2d vec)   {
        velocity = vec;
    };
    virtual void wall_collision(double xmax, double ymax) = 0;
    virtual void ball_collision(class ball& other) = 0;
};

class ball : public physical_object {
    double radius;
public:
    ball() {
        physical_object::x = 0;
        physical_object::y = 0;
        radius = 1;
        physical_object::mass = 1;
        physical_object::grav = true;
        physical_object::airres = true;
        physical_object::buoy = true;
        airrescons = circcons*airden*PI*radius/(mass*10000);
        volume = PI*sq(radius);
        velocity = Vector2d();
    };
    ball(double x, double y, double r, double mass, bool forces) {
        physical_object::x = x;
        physical_object::y = y;
        radius = r;
        physical_object::mass = mass;
        physical_object::grav = forces;
        physical_object::airres = forces;
        physical_object::buoy = forces;
        airrescons = circcons*airden*PI*radius/(mass*10000);
        volume = PI*sq(radius);
        velocity = Vector2d();
    };
    char type() {
        return 'b';
    };
    double get_radius() {
        return radius;
    };
    void apply_air_resistance();
    void wall_collision(double xmax, double ymax);
    void ball_collision(ball& other);
};

// Apply the earth's gravity to the calling object's velocity
void physical_object::apply_e_gravity() {
    if (grav)
        velocity.y += g/500;
}

// Apply the gravity generated by two objects' masses to themselves
void physical_object::apply_g_gravity(physical_object& other) {
    if (grav) {
        double omass = other.get_mass();
        Vector2d diff = Vector2d(x-other.x, y-other.y);
        double sdist = snorm(diff);
        double dir = direction(diff);
        double coss = cos(dir);
        double sine = sin(dir);
        double tforce = (G*omass)/sdist;
        // cout << tforce << endl;
        double oforce = (G*mass)/sdist;
        velocity.x -= tforce*coss;
        velocity.y -= tforce*sine;
        other.velocity.x += oforce*coss;
        other.velocity.y += oforce*sine;
    }
}

void physical_object::apply_velocity() {
    x += velocity.x/100;
    y += velocity.y/100;
}

Vector2d physical_object::get_pos() {
    return Vector2d(x, y);
}

Vector2d physical_object::get_velocity() {
    Vector2d res(velocity.x, velocity.y);
    return res;
}

void ball::apply_air_resistance() {
    if (airres) {
        double acc = airrescons*snorm(physical_object::velocity);
        double dir = direction(physical_object::velocity);
        physical_object::velocity.x -= acc*cos(dir)/500;
        physical_object::velocity.y -= acc*sin(dir)/500;
    }
}

void ball::wall_collision(double xmax, double ymax) {
    if (physical_object::x < 0 || physical_object::x > xmax - 2*radius)
        physical_object::velocity.x = -85*(physical_object::velocity.x)/100;
    if (physical_object::y < 0 || physical_object::y > ymax - 2*radius) {
        physical_object::velocity.y = -85*(physical_object::velocity.y)/100;
    }
    physical_object::x = fmax(0, fmin(physical_object::x, xmax - 2*radius));
    physical_object::y = fmax(0, fmin(physical_object::y, ymax - 2*radius));
}

void ball::ball_collision(ball& other) {
    double oradius = other.get_radius();
    Vector2d opos = vsum(other.get_pos(), Vector2d(oradius, oradius));
    double myx = physical_object::x + radius;
    double myy = physical_object::y + radius;
    double dist = sqrt(sq(myx - opos.x) + sq(myy - opos.y));
    if (dist < radius + oradius) {
        double omass = other.get_mass();
        Vector2d ovel = other.get_velocity();
        Vector2d vf1 = vsum(rprod(2*omass, ovel), rprod(mass-omass, physical_object::velocity));
        vf1 = rdiv(mass + omass, vf1);
        Vector2d vf2 = vsum(rprod(2*mass, physical_object::velocity), rprod(omass-mass, ovel));
        vf2 = rdiv(mass + omass, vf2);
        physical_object::velocity = vf1;
        other.change_velocity(vf2);
    }
}

int main() {
    sf::RenderWindow window(sf::VideoMode(video_max_x, video_max_y), "Bouncing balls");
    sf::VertexArray window_bg(sf::Quads, 4);
    int siz;

    window_bg[0].position = sf::Vector2f(0, 0);
    window_bg[1].position = sf::Vector2f(video_max_x, 0);
    window_bg[2].position = sf::Vector2f(video_max_x, video_max_y);
    window_bg[3].position = sf::Vector2f(0, video_max_y);

    vector<physical_object*> objs;
    vector<sf::CircleShape*> shapes;
    objs.resize(3);
    shapes.resize(3);

    //cout << objs.size() << endl;

    objs[0] = new ball(200.0, 200.0, 20.0, 20.0, true);
    objs[0]->add_velocity(Vector2d(20.0, 0.0));
    shapes[0] = new sf::CircleShape(20.0);
    Vector2d vect = objs[0]->get_pos();
    shapes[0]->setPosition(vect.x, vect.y);
    shapes[0]->setFillColor(Blue);

    objs[1] = new ball(400.0, 400.0, 20.0, 20.0, true);
    objs[1]->add_velocity(Vector2d(-20.0, -20.0));
    shapes[1] = new sf::CircleShape(20.0);
    vect = objs[1]->get_pos();
    shapes[1]->setPosition(vect.x, vect.y);
    shapes[1]->setFillColor(Red);

    objs[2] = NULL;

    siz = objs.size();
    //cout << siz << endl;

    for (int i = 0; i < 4; i++)
        window_bg[i].color = MWhite;

    while (window.isOpen()) {
        sf::Event event;
        sf::Vector2i mousePosition;
        double mx, my;

        // Events handling
		while (window.pollEvent(event)) {
			if (event.type == sf::Event::Closed)
				window.close();
            if (sf::Mouse::isButtonPressed(sf::Mouse::Left)) {
                if (objs[siz-1] == NULL) {
                    mousePosition = sf::Mouse::getPosition(window);
                    mx = mousePosition.x;
                    my = mousePosition.y;
                    objs[siz-1] = new ball(mx-30.0, my-30.0, 30.0, MMass, false);
                    shapes[siz-1] = new sf::CircleShape(30.0);
                    shapes[siz-1]->setPosition(mx-30.0, my-30.0);
                    shapes[siz-1]->setFillColor(MBlack);
                }
                else {
                    mousePosition = sf::Mouse::getPosition(window);
                    mx = mousePosition.x;
                    my = mousePosition.y;
                    objs[siz-1]->set_pos(mx-30.0, my-30.0);
                    objs[siz-1]->change_velocity(Vector2d(0.0, 0.0));
                }
            }
            if (!sf::Mouse::isButtonPressed(sf::Mouse::Left) && objs[siz-1] != NULL) {
                objs[siz-1] = NULL;
            }
        }

        // Calculating new positions
        for (int i = 0; i < siz && objs[i] != NULL; i++) {
            objs[i]->apply_velocity();
            objs[i]->apply_e_gravity();
            objs[i]->apply_air_resistance();
            objs[i]->apply_buoyancy();
            objs[i]->wall_collision(video_max_x, video_max_y);
            for (int j = i+1; j < siz && objs[j] != NULL; j++) {
                if (objs[j]->type() == 'b')
                    objs[i]->ball_collision(*((ball*)objs[j]));
                objs[i]->apply_g_gravity(*((ball*)objs[j]));
            }
        }

        // Drawing everything
        window.clear();
        window.draw(window_bg);
        for (int i = 0; i < siz && objs[i] != NULL; i++) {
            vect = objs[i]->get_pos();
            shapes[i]->setPosition(vect.x, vect.y);
            window.draw(*(shapes[i]));
        }
        window.display();
    }
}
